<!DOCTYPE html>
<html lang="zh-CN">
<head>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>九宫格翻牌 · 手动输入版（自动剩余次数 & 自动最佳线路）</title>
<style>
  :root{
    --gap:10px; --cell:84px; --radius:12px;
    --shadow:0 6px 16px rgba(0,0,0,.06);
    --border:#e5e7eb; --ink:#111827; --muted:#6b7280;
    --brand:#6366f1; --brand-weak:rgba(99,102,241,.18);
    --good:#10b981;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:#f9fafb; color:var(--ink);}
  .wrap{max-width:980px;margin:0 auto;padding:20px;display:flex;flex-direction:column;gap:16px;min-height:100vh}
  header{display:flex;justify-content:space-between;gap:12px;align-items:flex-start;flex-wrap:wrap}
  h1{margin:0;font-size:22px}
  .note{margin:6px 0 0;color:var(--muted);font-size:13px;max-width:700px}
  .main{display:grid;grid-template-columns: 1fr 360px;gap:18px}
  @media (max-width: 900px){.main{grid-template-columns:1fr}}
  .card{background:#fff;border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:var(--shadow)}
  .card h2{margin:0 0 10px;font-size:16px}
  .board-wrap{ position:relative; display:inline-block; }
  .grid3{display:grid;grid-template-columns:repeat(3,var(--cell));gap:var(--gap);justify-content:center}
  input.cell{
    width:var(--cell);height:var(--cell);border:1px solid #d1d5db;border-radius:var(--radius);
    background:#fff;display:flex;align-items:center;justify-content:center;
    text-align:center;font-weight:800;font-size:28px;box-shadow:var(--shadow);
    outline:none; position:relative;
  }
  input.cell:focus{border-color:#c7d2fe; box-shadow:0 0 0 3px rgba(99,102,241,.18)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{border:1px solid var(--border);background:#fff;padding:8px 12px;border-radius:12px;box-shadow:var(--shadow);cursor:pointer;font-size:14px}
  .btn:disabled{opacity:.6;cursor:default}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:8px 10px;align-items:center}
  .badge{display:inline-block;background:#eef2ff;border:1px solid #c7d2fe;color:#1f2937;border-radius:999px;padding:2px 8px;font-size:12px}
  .list{display:grid;gap:6px}
  .tip{font-size:12px;color:var(--muted)}
  .pair{display:flex;justify-content:space-between;background:#f3f4f6;border:1px solid var(--border);border-radius:8px;padding:6px 8px;font-size:13px}
  /* Highlights */
  .cell.rec{ outline:3px solid var(--brand); outline-offset:-3px; }
  .cell.bestline{ outline:3px solid var(--good); outline-offset:-3px; background:#ecfdf5; }
  .tag{ position:absolute; right:6px; bottom:6px; font-size:12px; background:#111827; color:#fff; border-radius:10px; padding:2px 6px; opacity:.92 }
  .banner{
    position:absolute; left:50%; transform:translateX(-50%);
    top:-34px; background:#111827; color:#fff; font-size:13px; padding:6px 10px;
    border-radius:10px; box-shadow:var(--shadow); white-space:nowrap;
  }
  .counter{font-size:13px;color:#111827;background:#fff;border:1px solid var(--border);padding:6px 10px;border-radius:12px;box-shadow:var(--shadow)}
  .warn{color:#b91c1c;font-weight:600}

  .logo-badge{font-family:'Pacifico',cursive;font-size:22px;font-weight:400;
    display:inline-flex;align-items:center;gap:6px;
    font-weight:800;font-size:13px;letter-spacing:.2px;
    padding:6px 10px;border-radius:999px;
    background:#ffffff; border:1px solid var(--border); box-shadow:var(--shadow); color:#111827;
    user-select:none;
  }
  .logo-dot{width:8px;height:8px;border-radius:999px;background:linear-gradient(135deg,#6366f1,#22c55e)}
    
/* ===  Fixed Logo & Cleanup === */
.logo-fixed{
  position: fixed; right: 12px; top: 12px; z-index: 1200;
  font-family:'Pacifico',cursive; font-size:22px; font-weight:400;
  display:inline-flex; align-items:center; gap:6px;
  padding:8px 14px; border-radius:999px;
  background:#fff; border:1px solid #e5e7eb; box-shadow:0 6px 16px rgba(0,0,0,.06);
  color:#111827;
}
.logo-fixed .logo-dot{width:8px;height:8px;border-radius:999px;background:linear-gradient(135deg,#6366f1,#22c55e)}
.site-header .logo-badge{ display:none !important; }
#clearBtn{ display:none !important; }


/* floating top bar for actions */
.topbar{
  position:fixed; left:12px; top:12px; z-index:1000;
  display:flex; gap:8px; align-items:center;
  background:rgba(255,255,255,.9);
  border:1px solid #e5e7eb;
  padding:6px 8px; border-radius:12px; box-shadow:0 6px 16px rgba(0,0,0,.08);
  backdrop-filter:saturate(140%) blur(4px);
}
.topbar .btn{padding:8px 12px; border-radius:12px; font-size:13px}
@media (max-width:480px){ .topbar{left:8px; top:8px} }

/* language toggle */
.langbar{
  position:fixed; right:12px; top:12px; z-index:1000;
  display:flex; align-items:center;
  background:rgba(255,255,255,.9);
  border:1px solid #e5e7eb;
  padding:6px 8px; border-radius:12px; box-shadow:0 6px 16px rgba(0,0,0,.08);
  backdrop-filter:saturate(140%) blur(4px);
}
.langbar .btn{padding:8px 12px; border-radius:12px; font-size:13px}
@media (max-width:480px){ .langbar{right:8px; top:8px} }


/* bottom-left logo with text */
.logo-bottom-left{
  position:fixed; left:12px; bottom:12px; z-index:1000;
  font-family:'Pacifico',cursive; font-size:20px; font-weight:400;
  display:inline-flex; align-items:center; gap:6px;
  padding:8px 14px; border-radius:999px;
  background:#fff; border:1px solid #e5e7eb; box-shadow:0 6px 16px rgba(0,0,0,.06);
  color:#111827;
}
.logo-bottom-left .logo-dot{width:8px;height:8px;border-radius:999px;background:linear-gradient(135deg,#6366f1,#22c55e)}

.update-note{
  max-width:980px;margin:0 auto;padding:10px 20px;
  border-radius:14px;border:1px solid #e8e8ff;
  background:linear-gradient(90deg,#fff7ed 0%, #f0f9ff 45%, #fff1f2 100%);
  color:#111827;font-size:13px;
  box-shadow:0 6px 16px rgba(0,0,0,.06);
  display:flex;align-items:center;gap:8px;flex-wrap:wrap;
}
.update-note .pill{
  font-weight:700;letter-spacing:.2px;
  background:#111827;color:#fff;border-radius:999px;padding:3px 8px;font-size:11px;
}
.update-note .date{font-weight:700}
.update-note .spark{
  width:8px;height:8px;border-radius:999px;
  background:radial-gradient(circle at 30% 30%, #fff, #f59e0b 60%, #ef4444 100%);
  box-shadow:0 0 6px rgba(245,158,11,.7);
}
@media (max-width:600px){ .update-note{font-size:12px;padding:8px 12px} }
</style>
</head>
<body>

<div class="topbar">
  <a href="index.html" class="btn" style="text-decoration:none;" id="homeLink">回到主页</a>
  <a href="CoreCalculator.html" class="btn" style="text-decoration:none;" id="coreLink">核心计算器</a>
</div>

</span>
<div class="langbar">
  <button class="btn" id="langToggle" type="button">EN</button>
</div>

</span>
<div class="update-note">
  <span class="spark" aria-hidden="true"></span>
  <span class="pill" id="updatePill">Update</span>
  <span class="date">2026/1/6</span>
  <span id="updateText">更新内容：新添加20%几率出现小精灵</span>
</div>

</span>
<div class="wrap">
  <header>
    <div>
      
      
    </div>
    <div class="row">
      <div id="autoCounter" class="counter">已打开：0/4 · 剩余：4</div>
      <button class="btn" id="clearBtn">清空</button>
      </span>
    </div>
  </header>

  <div class="main">
    <div class="card">
      <h2 id="boardTitle">输入当前棋面（1–9，不重复；未知留空）</h2>
      <div class="board-wrap">
        <div class="grid3" id="grid"></div>
        <div id="boardBanner" class="banner" style="display:none"></div>
      </div>
      <div class="row" style="margin-top:12px">
        <button class="btn" id="advBtn">计算最佳下一步</button>
        <button class="btn" id="lineBtn">计算最佳线路</button>
        <button class="btn" id="clearBtnInline">清空</button>
        <span id="msg" class="tip"></span>
      </div>
    </div>

    <div class="card">
      <h2 id="resultTitle">结果</h2>
      <div class="kv">
        <div id="statusLabel">状态：</div><div id="status">—</div>
        <div id="adviceLabel">建议：</div><div id="advice">—</div>
      </div>

      <div style="margin-top:12px">
        <div class="badge" id="scoreBadge">S → 积分对照</div>
        <div id="pairs" class="list" style="margin-top:8px"></div>
      </div>

      <div id="lines" style="margin-top:12px;display:none">
        <div class="badge" id="lineBadge">各线路期望（仅用于“最佳线路”计算）</div>
        <div id="lineList" class="list" style="margin-top:8px"></div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const SUM_TO_SCORE = {6:1680,7:84,8:630,9:280,10:42,11:34,12:180,13:120,14:53,15:105,16:53,17:144,18:48,19:202,20:105,21:51,22:420,23:840,24:1008};
  const LINES = [
    { key: "line_row1", cells: [[0,0],[0,1],[0,2]] },
    { key: "line_row2", cells: [[1,0],[1,1],[1,2]] },
    { key: "line_row3", cells: [[2,0],[2,1],[2,2]] },
    { key: "line_col1", cells: [[0,0],[1,0],[2,0]] },
    { key: "line_col2", cells: [[0,1],[1,1],[2,1]] },
    { key: "line_col3", cells: [[0,2],[1,2],[2,2]] },
    { key: "line_diag_main", cells: [[0,0],[1,1],[2,2]] },
    { key: "line_diag_anti", cells: [[0,2],[1,1],[2,0]] },
  ];
  const TARGET_OPEN = 4; // 开局1 + 可再翻3
  const BONUS_GROUPS = [
    [1,2,3],
    [7,8,9],
  ];

  const I18N = {
    zh: {
      title: "九宫格翻牌 · 手动输入版（自动剩余次数 & 自动最佳线路）",
      home: "回到主页",
      core_calc: "核心计算器",
      update_pill: "更新",
      update_text: "更新内容：新添加20%几率出现小精灵",
      board_title: "输入当前棋面（1–9，不重复；未知留空）",
      result_title: "结果",
      status_label: "状态：",
      advice_label: "建议：",
      score_badge: "S → 积分对照",
      line_badge: "各线路期望（仅用于“最佳线路”计算）",
      btn_best_next: "计算最佳下一步",
      btn_best_line: "计算最佳线路",
      btn_clear: "清空",
      counter: "已打开：{opened}/{total} · 剩余：{left}",
      duplicate: "⚠️ 输入重复：已有数字{v}",
      too_many: "⚠️ 已超过4张：请保持总共只填 4 格",
      status_opened: "已开 {opened} 张 · 请继续翻牌",
      status_progress: "样本数 {samples} · 已开 {opened} 张 · 剩余 {left}",
      status_end: "样本数 {samples} · 已开 {opened} 张 · 翻牌结束",
      advice_best_line: "最佳线路：<b>{line}</b>（期望积分≈ <b>{ev}</b>）",
      advice_best_next: "下一步建议翻：<b>({r}, {c})</b>；预计最高期望积分≈ <b>{ev}</b>",
      advice_all_known: "所有格子都已确定，直接选择最佳线路即可。",
      banner_best_line: "最佳线路：{line} · 期望积分≈{ev}",
      ev_tag: "EV≈{ev}",
      cleared: "已清空",
      line_row1: "第 1 行",
      line_row2: "第 2 行",
      line_row3: "第 3 行",
      line_col1: "第 1 列",
      line_col2: "第 2 列",
      line_col3: "第 3 列",
      line_diag_main: "主对角线",
      line_diag_anti: "副对角线",
      lang_toggle_en: "EN",
      lang_toggle_zh: "中文",
      dash: "—"
    },
    en: {
      title: "3x3 Flip Cards · Manual Input (Auto Remaining & Best Line)",
      home: "Home",
      core_calc: "Core Calculator",
      update_pill: "Update",
      update_text: "Update: 20% chance for the sprite to appear",
      board_title: "Enter the current board (1–9, no repeats; leave unknowns empty)",
      result_title: "Results",
      status_label: "Status:",
      advice_label: "Advice:",
      score_badge: "S → Score Table",
      line_badge: "Line expectations (for “Best Line” only)",
      btn_best_next: "Best Next Flip",
      btn_best_line: "Best Line",
      btn_clear: "Clear",
      counter: "Opened: {opened}/{total} · Left: {left}",
      duplicate: "⚠️ Duplicate input: number {v} already used",
      too_many: "⚠️ More than 4 cards opened: keep total at 4",
      status_opened: "Opened {opened} · Keep flipping",
      status_progress: "Samples {samples} · Opened {opened} · Left {left}",
      status_end: "Samples {samples} · Opened {opened} · Flips complete",
      advice_best_line: "Best line: <b>{line}</b> (expected ≈ <b>{ev}</b>)",
      advice_best_next: "Recommended flip: <b>({r}, {c})</b>; expected max ≈ <b>{ev}</b>",
      advice_all_known: "All cells are known. Pick the best line directly.",
      banner_best_line: "Best line: {line} · Expected ≈{ev}",
      ev_tag: "EV≈{ev}",
      cleared: "Cleared",
      line_row1: "Row 1",
      line_row2: "Row 2",
      line_row3: "Row 3",
      line_col1: "Col 1",
      line_col2: "Col 2",
      line_col3: "Col 3",
      line_diag_main: "Main diagonal",
      line_diag_anti: "Anti-diagonal",
      lang_toggle_en: "EN",
      lang_toggle_zh: "中文",
      dash: "—"
    }
  };

  const grid = document.getElementById('grid');
  const pairs = document.getElementById('pairs');
  const lineList = document.getElementById('lineList');
  const linesWrap = document.getElementById('lines');
  const statusEl = document.getElementById('status');
  const adviceEl = document.getElementById('advice');
  const clearBtn = document.getElementById('clearBtn');
  const advBtn = document.getElementById('advBtn');
  const lineBtn = document.getElementById('lineBtn');
  const clearBtnInline = document.getElementById('clearBtnInline');
  const msg = document.getElementById('msg');
  const banner = document.getElementById('boardBanner');
  const counterEl = document.getElementById('autoCounter');
  const homeLink = document.getElementById('homeLink');
  const coreLink = document.getElementById('coreLink');
  const updatePill = document.getElementById('updatePill');
  const updateText = document.getElementById('updateText');
  const boardTitle = document.getElementById('boardTitle');
  const resultTitle = document.getElementById('resultTitle');
  const statusLabel = document.getElementById('statusLabel');
  const adviceLabel = document.getElementById('adviceLabel');
  const scoreBadge = document.getElementById('scoreBadge');
  const lineBadge = document.getElementById('lineBadge');
  const langToggle = document.getElementById('langToggle');

  let currentLang = (localStorage.getItem('flipgame_lang') || '').toLowerCase();
  if(currentLang !== 'zh' && currentLang !== 'en'){
    const navLang = (navigator.language || '').toLowerCase();
    currentLang = navLang.startsWith('zh') ? 'zh' : 'en';
  }

  function t(key, vars){
    const dict = I18N[currentLang] || I18N.zh;
    let str = dict[key] || I18N.zh[key] || '';
    if(vars){
      str = str.replace(/\{(\w+)\}/g, (_, k)=> (vars[k] !== undefined ? vars[k] : ''));
    }
    return str;
  }

  function lineName(idx){
    return t(LINES[idx].key);
  }

  function setStaticText(){
    document.title = t('title');
    document.documentElement.lang = currentLang === 'zh' ? 'zh-CN' : 'en';
    if(homeLink) homeLink.textContent = t('home');
    if(coreLink) coreLink.textContent = t('core_calc');
    if(updatePill) updatePill.textContent = t('update_pill');
    if(updateText) updateText.textContent = t('update_text');
    if(boardTitle) boardTitle.textContent = t('board_title');
    if(resultTitle) resultTitle.textContent = t('result_title');
    if(statusLabel) statusLabel.textContent = t('status_label');
    if(adviceLabel) adviceLabel.textContent = t('advice_label');
    if(scoreBadge) scoreBadge.textContent = t('score_badge');
    if(lineBadge) lineBadge.textContent = t('line_badge');
    if(advBtn) advBtn.textContent = t('btn_best_next');
    if(lineBtn) lineBtn.textContent = t('btn_best_line');
    if(clearBtn) clearBtn.textContent = t('btn_clear');
    if(clearBtnInline) clearBtnInline.textContent = t('btn_clear');
    if(langToggle) langToggle.textContent = currentLang === 'zh' ? t('lang_toggle_en') : t('lang_toggle_zh');
  }

  function setLang(lang){
    currentLang = lang;
    localStorage.setItem('flipgame_lang', lang);
    setStaticText();
    updateCounter();
    pipeline();
  }

  // Build inputs
  const inputs = [];
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      const inp = document.createElement('input');
      inp.type = 'text'; inp.maxLength = 1; inp.placeholder = '?';
      inp.className = 'cell'; inp.dataset.r = r; inp.dataset.c = c;
      inp.addEventListener('input', ()=>{
        inp.value = inp.value.replace(/[^1-9]/g, '');
        clearHighlights();
        pipeline();
      });
      inputs.push(inp); grid.appendChild(inp);
    }
  }

  function clearHighlights(){
    inputs.forEach(el=>{
      el.classList.remove('rec','bestline');
    });
    document.querySelectorAll('.tag').forEach(x=>x.remove());
    banner.style.display='none';
  }

  clearBtn.addEventListener('click', ()=>{
    inputs.forEach(i=>i.value='');
    statusEl.textContent = t('dash');
    adviceEl.textContent = t('dash');
    linesWrap.style.display='none';
    msg.textContent = t('cleared');
    clearHighlights(); updateCounter();
  });

  function renderPairs(){
    pairs.innerHTML='';
    Object.entries(SUM_TO_SCORE).sort((a,b)=>Number(a[0])-Number(b[0])).forEach(([s,sc])=>{
      const row = document.createElement('div');
      row.className='pair';
      row.innerHTML = `<span>S=${s}</span><span style="font-weight:600">${sc}</span>`;
      pairs.appendChild(row);
    });
  }
  renderPairs();

  function getState(){
    const board = [[null,null,null],[null,null,null],[null,null,null]];
    const revealed = [[false,false,false],[false,false,false],[false,false,false]];
    let filled=0;
    for(let r=0;r<3;r++){
      for(let c=0;c<3;c++){
        const v = inputs[r*3+c].value.trim();
        if(v){ board[r][c]=Number(v); revealed[r][c]=true; filled++; }
      }
    }
    return {board, revealed, opened: filled};
  }

  function validateUnique(board){
    const used = new Set();
    for(let r=0;r<3;r++){
      for(let c=0;c<3;c++){
        const v=board[r][c];
        if(v!=null){
          if(used.has(v)){ return {ok:false, msg:t('duplicate', {v})}; }
          used.add(v);
        }
      }
    }
    return {ok:true};
  }

  function updateCounter(){
    const st = getState();
    const opened = st.opened;
    const left = Math.max(0, TARGET_OPEN - opened);
    counterEl.textContent = t('counter', {opened: Math.min(opened, TARGET_OPEN), total: TARGET_OPEN, left});
    return {opened, left};
  }

  function sampleBoards(state, N=2500){
    const {board, revealed} = state;
    const used = new Set(); for(let r=0;r<3;r++){ for(let c=0;c<3;c++){ if(revealed[r][c]) used.add(board[r][c]); }}
    const remaining = [1,2,3,4,5,6,7,8,9].filter(x=>!used.has(x));
    const unknown = []; for(let r=0;r<3;r++){ for(let c=0;c<3;c++){ if(!revealed[r][c]) unknown.push([r,c]); }}
    const samples=[];
    function deepCopy(x){ return JSON.parse(JSON.stringify(x)); }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
    if(unknown.length===0){ samples.push(deepCopy(board)); return samples; }
    for(let i=0;i<N;i++){ const nums=remaining.slice(); shuffle(nums); const b=deepCopy(board); for(let j=0;j<unknown.length;j++){ const [r,c]=unknown[j]; b[r][c]=nums[j]; } samples.push(b); }
    return samples;
  }
  function lineSum(b, idx){ return LINES[idx].cells.map(([r,c])=>b[r][c]).reduce((a,b)=>a+b,0); }

  function expectedLineScoreWithBonus(b, revealed, idx){
    const cells = LINES[idx].cells;
    const values = cells.map(([r,c])=>b[r][c]);
    const baseSum = values[0] + values[1] + values[2];
    const baseScore = SUM_TO_SCORE[baseSum] || 0;
    for(const group of BONUS_GROUPS){
      const inGroup = values.map(v=>group.includes(v));
      const count = inGroup.filter(Boolean).length;
      if(count === 2){
        const missing = group.find(n=>!values.includes(n));
        let missingRevealed = false;
        for(let r=0;r<3;r++){
          for(let c=0;c<3;c++){
            if(revealed[r][c] && b[r][c] === missing){ missingRevealed = true; break; }
          }
          if(missingRevealed) break;
        }
        if(missingRevealed){ return baseScore; }
        const thirdIdx = inGroup.findIndex(x=>!x);
        const [r,c] = cells[thirdIdx];
        const current = values[thirdIdx];
        const newSum = baseSum + (missing - current);
        const newScore = SUM_TO_SCORE[newSum] || 0;
        return 0.8 * baseScore + 0.2 * newScore;
      }
    }
    return baseScore;
  }

  function expectedBestScore_noFlip(samples, revealed, includeSprite){
    let best = -Infinity, bestIdx = 0, perLine = new Array(8).fill(0);
    for(let l=0;l<8;l++){
      let acc=0;
      for(const s of samples){
        const score = includeSprite ? expectedLineScoreWithBonus(s, revealed, l) : (SUM_TO_SCORE[lineSum(s, l)] || 0);
        acc += score;
      }
      const avg = acc / samples.length; perLine[l]=avg;
      if(avg>best){ best=avg; bestIdx=l; }
    }
    return {best, bestIdx, perLine};
  }
  function planEV(samples, flips, revealed, includeSprite){
    if(flips<=0){ return expectedBestScore_noFlip(samples, revealed, includeSprite).best; }
    const unknown=[]; for(let r=0;r<3;r++){ for(let c=0;c<3;c++){ if(!revealed[r][c]) unknown.push([r,c]); }}
    let best=-Infinity;
    for(const [r,c] of unknown){
      const buckets=new Map();
      for(const b of samples){ const v=b[r][c]; if(!buckets.has(v)) buckets.set(v,[]); buckets.get(v).push(b); }
      let exp=0;
      for(const [v,subset] of buckets){
        const nextMask = revealed.map(row=>row.slice()); nextMask[r][c]=true;
        exp += (subset.length/samples.length) * planEV(subset, flips-1, nextMask, includeSprite);
      }
      if(exp>best) best=exp;
    }
    return best;
  }

  function bestNextFlip(state, flipsLeft, includeSprite){
    const samples = sampleBoards(state, 2500);
    const {revealed} = state;
    const unknown=[]; for(let r=0;r<3;r++){ for(let c=0;c<3;c++){ if(!revealed[r][c]) unknown.push([r,c]); }}
    if(unknown.length===0){ return {ev: expectedBestScore_noFlip(samples, revealed, includeSprite).best, cell: null}; }
    let globalBest=-Infinity, bestCell=null;
    for(const [r,c] of unknown){
      const buckets=new Map(); for(const b of samples){ const v=b[r][c]; if(!buckets.has(v)) buckets.set(v,[]); buckets.get(v).push(b); }
      let exp=0;
      for(const [v,subset] of buckets){
        const mask = revealed.map(row=>row.slice()); mask[r][c]=true;
        const val = planEV(subset, flipsLeft-1, mask, includeSprite);
        exp += (subset.length/samples.length) * val;
      }
      if(exp>globalBest){ globalBest=exp; bestCell=[r,c]; }
    }
    return {ev:globalBest, cell:bestCell};
  }

  function applyBestNextHighlight(cell, ev){
    clearHighlights();
    if(!cell) return;
    const [r,c]=cell, idx=r*3+c;
    const el = inputs[idx];
    el.classList.add('rec');
    try { el.focus({preventScroll:true}); el.select(); } catch(e) { try { el.focus(); el.select(); } catch(e2) {} }
    const tag = document.createElement('div');
    tag.className='tag';
    tag.textContent = t('ev_tag', {ev: ev.toFixed(1)});
    el.parentElement ? el.parentElement.appendChild(tag) : el.appendChild(tag);
  }

  function applyBestLineHighlight(bestIdx, ev){
    clearHighlights();
    for(const [r,c] of LINES[bestIdx].cells){
      inputs[r*3+c].classList.add('bestline');
    }
    banner.textContent = t('banner_best_line', {line: lineName(bestIdx), ev: ev.toFixed(1)});
    banner.style.display='block';
  }

  function pipeline(){
    const st = getState();
    const uniq = validateUnique(st.board);
    const {opened, left} = updateCounter();

    if(!uniq.ok){
      msg.textContent = uniq.msg;
      adviceEl.textContent = t('dash');
      statusEl.textContent = t('dash');
      linesWrap.style.display='none';
      clearHighlights();
      return;
    }
    msg.textContent='';

    if(opened > TARGET_OPEN){
      msg.innerHTML = `<span class="warn">${t('too_many')}</span>`;
      adviceEl.textContent = t('dash');
      statusEl.textContent = t('dash');
      linesWrap.style.display='none';
      clearHighlights();
      return;
    }

    if(opened === TARGET_OPEN){
      // 自动计算最佳线路（无额外翻牌）
      const samples = sampleBoards(st, 4000);
      const {best, bestIdx, perLine} = expectedBestScore_noFlip(samples, st.revealed, false);
      adviceEl.innerHTML = t('advice_best_line', {line: lineName(bestIdx), ev: best.toFixed(1)});
      statusEl.textContent = t('status_end', {samples: 4000, opened});
      linesWrap.style.display='block';
      lineList.innerHTML = '';
      for(let i=0;i<8;i++){
        const div=document.createElement('div');
        div.className='pair';
        div.innerHTML=`<span>${lineName(i)}</span><span style="font-weight:600">${perLine[i].toFixed(1)}</span>`;
        if(i===bestIdx){ div.style.borderColor='#6366f1'; div.style.background='#eef2ff'; }
        lineList.appendChild(div);
      }
      applyBestLineHighlight(bestIdx, best);
      return;
    }

    // 未满 4 张：给最佳下一步建议
    if(opened < TARGET_OPEN){
      if (opened === 0) {
        adviceEl.textContent = t('dash');
        statusEl.textContent = t('status_opened', {opened});
        linesWrap.style.display='none';
        try { clearHighlights(); } catch(e) {}
        return;
      }

      const {ev, cell} = bestNextFlip(st, TARGET_OPEN - opened, true);
      if(!cell){
        adviceEl.textContent = t('advice_all_known');
        statusEl.textContent = t('dash');
        linesWrap.style.display='none';
        return;
      }
      const [r,c]=cell;
      adviceEl.innerHTML = t('advice_best_next', {r: r+1, c: c+1, ev: ev.toFixed(1)});
      statusEl.textContent = t('status_progress', {samples: 2500, opened, left: TARGET_OPEN-opened});
      linesWrap.style.display='none';
      applyBestNextHighlight(cell, ev);
    }
  }

  // manual buttons still available
  document.getElementById('advBtn').addEventListener('click', pipeline);
  document.getElementById('lineBtn').addEventListener('click', pipeline);
  if(langToggle){
    langToggle.addEventListener('click', ()=>{ setLang(currentLang === 'zh' ? 'en' : 'zh'); });
  }

  // init
  setStaticText();
  updateCounter();
  pipeline();
  window.flipgameI18n = { t: t };
})();

// inline clear next to '计算最佳线路'
(function(){
  var inlineClear = document.getElementById('clearBtnInline');
  if(inlineClear){
    inlineClear.addEventListener('click', function(){
      var real = document.getElementById('clearBtn');
      if(real){ real.click(); return; }
      try {
        var inputs = document.querySelectorAll('#grid input.cell');
        inputs.forEach(i=>i.value='');
        var msg = document.getElementById('msg'), statusEl = document.getElementById('status'), adviceEl = document.getElementById('advice');
        var i18n = window.flipgameI18n;
        var t = i18n && typeof i18n.t === 'function' ? i18n.t : null;
        if(msg) msg.textContent = t ? t('cleared') : '已清空';
        if(statusEl) statusEl.textContent = t ? t('dash') : '—';
        if(adviceEl) adviceEl.textContent = t ? t('dash') : '—';
        var linesWrap = document.getElementById('lines'); if(linesWrap) linesWrap.style.display='none';
        if(typeof clearHighlights === 'function') clearHighlights();
        if(typeof updateCounter === 'function') updateCounter();
      } catch(e){}
    });
  }
})();

</script>

<div style="position:fixed;right:10px;bottom:10px;opacity:.65;pointer-events:none;font-size:12px;background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:4px 8px;box-shadow:0 6px 16px rgba(0,0,0,.06)">
  
</div>




<div class="logo-bottom-left">
  <span class="logo-dot"></span> By ShinE
</div>

</body>
</html>
